'use server'

//handles all server interactions

import {connectDB} from '@/lib/db';
import {BookingModel} from '@/Models/Booking'
import {UserModel} from '@/Models/User'
import {Booking, PopulatedRawBooking, User, RawUser} from '@/types'
import {revalidatePath} from 'next/cache';
import {auth} from '@/app/auth';

//ACTION: create a booking
//TODO: Remove "data.user" from input. We get it from the session. (DONE)
export async function createBookingAction(data: {slot: string}){

    try{
        //check session
        const session = await auth();
        if (!session || !session.user){
            return{success: false, error: "Please log in first."}
        }

        await connectDB();
        
        //catch duplicate bookings
        const isBooked = await BookingModel.findOne({slot: data.slot});
        if(isBooked){
            return{success: false, error: "Slot is already booked"}
        }

        //create the document
        const newBooking = await BookingModel.create({
            user: session.user.id,
            slot: data.slot
            //createdAt has a default value in Models/Booking.ts so we don't need to give it anything
        });

        //clear cache so frontend can update with new data
        revalidatePath('/MyBookings'); //url path not file path
        revalidatePath('/Bookings');

        return {success: true, id: newBooking._id.toString()};
    }
    catch(error){
        console.log("Booking could not be created: ", error);
        return {success: false, error: "Database save failed"};
    }
}

//ACTION: get all bookings

export async function getBookingsAction(){
    try{
        await connectDB();

        //fetch all data and convert to plain js objects using .lean() for optimization
        //sort data by date of creation
        const docs = await BookingModel.find({})
        .sort({ createdAt: -1 })
        .populate('user') 
        .lean<PopulatedRawBooking[]>();

        //map to frontend Booking interface (for safety and frontend access)
        return docs.map((doc: PopulatedRawBooking) => ({
            id: doc._id.toString(),
            //safety: since BookingModel says doc.user is an ObjectID, convert to string before sending to frontend.
            user: {
                id: doc.user._id.toString(),
                name: doc.user.name,
                email: doc.user.email
            },
            slot: doc.slot,
            createdAt: doc.createdAt.getTime(),
        })) as Booking[]; //return array of Booking objects
    }
    catch(error){
        console.log("Fetch failed:", error);
        return [] //return empty array to avoid client crashes
    }
}


//ACTION: cancel bookings
export async function cancelBookingAction(bookingId: string){
    try{
        await connectDB();

        await BookingModel.findByIdAndDelete(bookingId);

        //revalidate
        revalidatePath('/MyBookings'); 
        revalidatePath('/Bookings');

        return{success: true}
    }
    catch(error){
        console.log("Failed to delete booking: ", error);
        return {success: false, error: "Cancellation failed."}
    }
}

//ACTION: create a user
//moved logic to authactions.ts
/*
export async function createUserAction(data: Omit<User, 'id'>){
    try{
        await connectDB();

        const newUser = await UserModel.create({
            name: data.name,
            email: data.email
            //createdAt has default value, IDs are generated by mongodb
        })

        return{success: true, id: newUser._id.toString()}
    }
    catch(error){
        console.log("Failed to create user account: ", error)
        return{success: false, error: "Failed to save user"}
    }
}*/

//ACTION: get all users (for admins)
//TODO: add check if user is an admin
export async function getUsersAction(){

    try{
        await connectDB();

        const users = await UserModel.find({}).sort({createdAt: -1}).lean<RawUser[]>();

        return users.map((user: RawUser) => ({
            id: user._id.toString(),
            name: user.name,
            email: user.email,
            createdAt: user.createdAt.getTime(),
        })) as User[]; //return array of users
    }
    catch(error){
        console.log("Failed to get users", error)
        return []
    }
}
