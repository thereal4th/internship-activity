'use server'

//handles all server interactions

import clientPromise from '@/lib/db';
import {BookingModel} from '@/Models/Booking'
import {UserModel} from '@/Models/User'
import {Booking, RawBooking, User, RawUser} from '@/types'
import {revalidatePath} from 'next/cache';
import mongoose from 'mongoose';

//HELPER: ensure mongoose is connected to singleton

export async function connectDB(){
    //if there is a conneciton, do nothing
    if (mongoose.connection.readyState >= 1) return;
    else{
        await clientPromise;
        await mongoose.connect(process.env.MONGODB_CONNECTION_STRING!); //! - non-null assertion
    }
}

//ACTION: create a booking
//TODO: modify to ignore user input and grab ID from session instead for security
export async function createBookingAction(data: Omit<Booking, 'id'|'createdAt'>){

    try{
        await connectDB();
        
        //create the document
        const newBooking = await BookingModel.create({
            //no need to create IDs, mongodb has built-in IDs
            user: data.user,
            slot: data.slot
            //createdAt has a default value in Models/Booking.ts so we don't need to give it anything
        });

        //clear cache so frontend can update with new data
        revalidatePath('/MyBookings'); //url path not file path
        revalidatePath('/Bookings');

        return {success: true, id: newBooking._id.toString()};
    }
    catch(error){
        console.log("Booking could not be created: ", error);
        return {success: false, error: "Database save failed"};
    }
}

//ACTION: get all bookings

export async function getBookingsAction(){
    try{
        await connectDB();

        //fetch all data and convert to plain js objects using .lean() for optimization
        //sort data by date of creation
        const docs = await BookingModel.find({}).sort({createdAt:-1}).lean<RawBooking[]>(); //lean should know the resulting interface
        
        //map to frontend Booking interface (for safety and frontend access)
        return docs.map((doc: RawBooking) => ({
            id: doc._id.toString(),
            user: doc.user,
            slot: doc.slot,
            createdAt: doc.createdAt.getTime(),
        })) as Booking[]; //return array of Booking objects
    }
    catch(error){
        console.log("Fetch failed:", error);
        return [] //return empty array to avoid client crashes
    }
}


//ACTION: cancel bookings
export async function cancelBookingAction(bookingId: string){
    try{
        await connectDB();

        await BookingModel.findByIdAndDelete(bookingId);

        //revalidate
        revalidatePath('/MyBookings'); 
        revalidatePath('/Bookings');

        return{success: true}
    }
    catch(error){
        console.log("Failed to delete booking: ", error);
        return {success: false, error: "Cancellation failed."}
    }
}

//ACTION: create a user
//moved logic to authactions.ts
/*
export async function createUserAction(data: Omit<User, 'id'>){
    try{
        await connectDB();

        const newUser = await UserModel.create({
            name: data.name,
            email: data.email
            //createdAt has default value, IDs are generated by mongodb
        })

        return{success: true, id: newUser._id.toString()}
    }
    catch(error){
        console.log("Failed to create user account: ", error)
        return{success: false, error: "Failed to save user"}
    }
}*/

//ACTION: get all users (for admins)
//TODO: add check if user is an admin
export async function getUsersAction(){

    try{
        await connectDB();

        const users = await UserModel.find({}).sort({createdAt: -1}).lean<RawUser[]>();

        return users.map((user: RawUser) => ({
            id: user._id.toString(),
            name: user.name,
            email: user.email,
            createdAt: user.createdAt.getTime(),
        })) as User[]; //return array of users
    }
    catch(error){
        console.log("Failed to get users", error)
        return []
    }
}
